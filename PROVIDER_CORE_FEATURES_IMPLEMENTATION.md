# å•†æˆ·æ ¸å¿ƒåŠŸèƒ½å®ç°æ–¹æ¡ˆ
## Google æ—¥å†åŒæ­¥ + æœåŠ¡ç®¡ç† + åº—å‘˜æ´¾å• + è´¢åŠ¡æ ¸ç®— + ç»è¥çœ‹æ¿

---

## ğŸ“‹ ç›®å½•

1. [åŠŸèƒ½æ¦‚è¿°](#åŠŸèƒ½æ¦‚è¿°)
2. [æ•°æ®åº“è®¾è®¡æ‰©å±•](#æ•°æ®åº“è®¾è®¡æ‰©å±•)
3. [Google æ—¥å†åŒå‘åŒæ­¥](#google-æ—¥å†åŒå‘åŒæ­¥)
4. [æœåŠ¡ç®¡ç†ç³»ç»Ÿ](#æœåŠ¡ç®¡ç†ç³»ç»Ÿ)
5. [åº—å‘˜æ´¾å•ç³»ç»Ÿ](#åº—å‘˜æ´¾å•ç³»ç»Ÿ)
6. [è´¢åŠ¡æ ¸ç®—ç³»ç»Ÿ](#è´¢åŠ¡æ ¸ç®—ç³»ç»Ÿ)
7. [ç»è¥çœ‹æ¿](#ç»è¥çœ‹æ¿)
8. [API è®¾è®¡](#api-è®¾è®¡)
9. [å‰ç«¯ç•Œé¢è®¾è®¡](#å‰ç«¯ç•Œé¢è®¾è®¡)
10. [å®ç°æ­¥éª¤](#å®ç°æ­¥éª¤)

---

## ğŸ¯ åŠŸèƒ½æ¦‚è¿°

### æ ¸å¿ƒä»·å€¼
ä¸ºå•†æˆ·æä¾›å®Œæ•´çš„é¢„çº¦ç®¡ç†ã€å‘˜å·¥è°ƒåº¦ã€è´¢åŠ¡æ ¸ç®—å’Œç»è¥åˆ†æèƒ½åŠ›ï¼Œå®ç°ï¼š
- âœ… å¤šæ¥æºé¢„çº¦ç»Ÿä¸€ç®¡ç†ï¼ˆå¹³å° + Googleæ—¥å† + å…¶ä»–æ¸ é“ï¼‰
- âœ… çµæ´»çš„æœåŠ¡é…ç½®ï¼ˆæœåŠ¡é¡¹ç›®ã€æ—¶é•¿ã€ä»·æ ¼ï¼‰
- âœ… æ™ºèƒ½åº—å‘˜æ´¾å•å’Œå·¥ä½œé‡åˆ†é…
- âœ… è‡ªåŠ¨åŒ–è´¢åŠ¡æ ¸ç®—ï¼ˆå‘˜å·¥ææˆã€åº—é“ºæ”¶å…¥ï¼‰
- âœ… å®æ—¶ç»è¥æ•°æ®çœ‹æ¿

### ä¸šåŠ¡æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å®¢æˆ·é¢„çº¦æ¥æº   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         â”‚         â”‚          â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚å¹³å°  â”‚  â”‚Googleâ”‚  â”‚ç”µè¯   â”‚  â”‚ç°åœº    â”‚
â”‚é¢„çº¦  â”‚  â”‚æ—¥å†  â”‚  â”‚é¢„çº¦   â”‚  â”‚é¢„çº¦    â”‚
â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
    â”‚        â”‚         â”‚          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ é¢„çº¦è®¢å•æ±   â”‚ â†’ è‡ªåŠ¨åŒæ­¥åˆ°Googleæ—¥å†
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ æ™ºèƒ½æ´¾å•    â”‚
         â”‚ (è‡ªåŠ¨/æ‰‹åŠ¨) â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                   â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚åº—å‘˜Aæ¥å•â”‚      â”‚åº—å‘˜Bæ¥å•  â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
    â”‚                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ æœåŠ¡å®Œæˆ    â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                   â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚åº—å‘˜ææˆ â”‚      â”‚åº—é“ºæ”¶å…¥   â”‚
â”‚è‡ªåŠ¨è®¡ç®— â”‚      â”‚å®æ—¶ç»Ÿè®¡   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ ç»è¥çœ‹æ¿    â”‚
         â”‚ æ•°æ®åˆ†æ    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡æ‰©å±•

### 1. åº—å‘˜ç®¡ç†è¡¨ï¼ˆæ–°å¢ï¼‰

```sql
-- åº—å‘˜è¡¨
CREATE TABLE staff_members (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_id UUID NOT NULL REFERENCES provider_profiles(id) ON DELETE CASCADE,

  -- åŸºæœ¬ä¿¡æ¯
  name TEXT NOT NULL,
  email TEXT,
  phone TEXT NOT NULL,
  avatar_url TEXT,

  -- èŒä½ä¿¡æ¯
  position TEXT NOT NULL, -- 'TECHNICIAN', 'STYLIST', 'THERAPIST', 'MANAGER'
  specialties TEXT[], -- æ“…é•¿çš„æœåŠ¡ç±»å‹
  skill_level TEXT DEFAULT 'INTERMEDIATE', -- 'JUNIOR', 'INTERMEDIATE', 'SENIOR', 'EXPERT'

  -- å·¥ä½œçŠ¶æ€
  status TEXT DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'INACTIVE', 'ON_LEAVE')),

  -- ææˆè®¾ç½®
  commission_type TEXT DEFAULT 'PERCENTAGE', -- 'PERCENTAGE', 'FIXED', 'TIERED'
  commission_rate DECIMAL(5, 2), -- ç™¾åˆ†æ¯”ï¼Œå¦‚ 30.00 è¡¨ç¤º 30%
  commission_fixed DECIMAL(10, 2), -- å›ºå®šé‡‘é¢
  commission_tiers JSONB, -- é˜¶æ¢¯ææˆé…ç½®

  -- å·¥ä½œæ—¶é—´
  work_schedule JSONB, -- å·¥ä½œç­è¡¨

  -- æ—¥å†åŒæ­¥
  google_calendar_id TEXT, -- å‘˜å·¥ä¸ªäºº Google æ—¥å† ID
  sync_to_google BOOLEAN DEFAULT FALSE,

  -- ç»Ÿè®¡æ•°æ®
  total_appointments INTEGER DEFAULT 0,
  total_revenue DECIMAL(10, 2) DEFAULT 0,
  average_rating DECIMAL(3, 2) DEFAULT 0,

  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),

  CONSTRAINT fk_provider FOREIGN KEY (provider_id) REFERENCES provider_profiles(id)
);

CREATE INDEX idx_staff_provider_id ON staff_members(provider_id);
CREATE INDEX idx_staff_status ON staff_members(status);
```

### 2. æ‰©å±•é¢„çº¦è¡¨ï¼ˆä¿®æ”¹ï¼‰

```sql
-- ä¸ºç°æœ‰ appointments è¡¨æ·»åŠ åº—å‘˜ç›¸å…³å­—æ®µ
ALTER TABLE appointments
ADD COLUMN staff_id UUID REFERENCES staff_members(id),
ADD COLUMN assignment_type TEXT DEFAULT 'AUTO' CHECK (assignment_type IN ('AUTO', 'MANUAL', 'CUSTOMER_REQUEST')),
ADD COLUMN assigned_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN assigned_by UUID REFERENCES users(id),
ADD COLUMN staff_notes TEXT,
ADD COLUMN actual_start_time TIMESTAMP WITH TIME ZONE,
ADD COLUMN actual_end_time TIMESTAMP WITH TIME ZONE,
ADD COLUMN actual_duration INTEGER, -- å®é™…æœåŠ¡æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
ADD COLUMN booking_source TEXT DEFAULT 'PLATFORM' CHECK (booking_source IN ('PLATFORM', 'GOOGLE_CALENDAR', 'PHONE', 'WALK_IN', 'OTHER'));

-- æ·»åŠ ç´¢å¼•
CREATE INDEX idx_appointments_staff_id ON appointments(staff_id);
CREATE INDEX idx_appointments_booking_source ON appointments(booking_source);
CREATE INDEX idx_appointments_assigned_at ON appointments(assigned_at);
```

### 3. è´¢åŠ¡è®°å½•è¡¨ï¼ˆæ–°å¢ï¼‰

```sql
-- è´¢åŠ¡äº¤æ˜“è®°å½•
CREATE TABLE financial_transactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_id UUID NOT NULL REFERENCES provider_profiles(id) ON DELETE CASCADE,
  appointment_id UUID REFERENCES appointments(id),
  staff_id UUID REFERENCES staff_members(id),

  -- äº¤æ˜“ä¿¡æ¯
  transaction_type TEXT NOT NULL CHECK (transaction_type IN ('REVENUE', 'COMMISSION', 'REFUND', 'ADJUSTMENT')),
  amount DECIMAL(10, 2) NOT NULL,
  currency TEXT DEFAULT 'USD',

  -- åˆ†æˆä¿¡æ¯
  service_amount DECIMAL(10, 2), -- æœåŠ¡åŸä»·
  platform_fee DECIMAL(10, 2), -- å¹³å°æŠ½æˆ
  staff_commission DECIMAL(10, 2), -- åº—å‘˜ææˆ
  provider_revenue DECIMAL(10, 2), -- å•†æˆ·æ”¶å…¥

  -- è®¡ç®—ä¾æ®
  commission_rate DECIMAL(5, 2), -- ä½¿ç”¨çš„ææˆæ¯”ä¾‹
  calculation_method TEXT, -- 'PERCENTAGE', 'FIXED', 'TIERED'
  calculation_details JSONB, -- è®¡ç®—è¯¦æƒ…

  -- ç»“ç®—çŠ¶æ€
  settlement_status TEXT DEFAULT 'PENDING' CHECK (settlement_status IN ('PENDING', 'PROCESSING', 'SETTLED', 'CANCELLED')),
  settled_at TIMESTAMP WITH TIME ZONE,

  -- å¤‡æ³¨
  notes TEXT,

  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

CREATE INDEX idx_transactions_provider_id ON financial_transactions(provider_id);
CREATE INDEX idx_transactions_staff_id ON financial_transactions(staff_id);
CREATE INDEX idx_transactions_appointment_id ON financial_transactions(appointment_id);
CREATE INDEX idx_transactions_created_at ON financial_transactions(created_at);
CREATE INDEX idx_transactions_settlement_status ON financial_transactions(settlement_status);
```

### 4. å¤–éƒ¨æ—¥å†åŒæ­¥è¡¨ï¼ˆæ–°å¢ï¼‰

```sql
-- Google æ—¥å†åŒæ­¥é…ç½®
CREATE TABLE calendar_sync_configs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_id UUID NOT NULL REFERENCES provider_profiles(id) ON DELETE CASCADE,

  -- Google OAuth ä¿¡æ¯
  google_calendar_id TEXT NOT NULL,
  access_token TEXT NOT NULL, -- åŠ å¯†å­˜å‚¨
  refresh_token TEXT NOT NULL, -- åŠ å¯†å­˜å‚¨
  token_expiry TIMESTAMP WITH TIME ZONE,

  -- åŒæ­¥è®¾ç½®
  sync_enabled BOOLEAN DEFAULT TRUE,
  sync_direction TEXT DEFAULT 'BIDIRECTIONAL' CHECK (sync_direction IN ('TO_GOOGLE', 'FROM_GOOGLE', 'BIDIRECTIONAL')),

  -- åŒæ­¥è§„åˆ™
  sync_rules JSONB, -- è‡ªå®šä¹‰åŒæ­¥è§„åˆ™
  auto_accept_external BOOLEAN DEFAULT FALSE, -- æ˜¯å¦è‡ªåŠ¨æ¥å—å¤–éƒ¨æ—¥å†äº‹ä»¶

  -- åŒæ­¥çŠ¶æ€
  last_sync_at TIMESTAMP WITH TIME ZONE,
  sync_status TEXT DEFAULT 'ACTIVE',
  sync_errors JSONB,

  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- æ—¥å†åŒæ­¥æ—¥å¿—
CREATE TABLE calendar_sync_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  config_id UUID NOT NULL REFERENCES calendar_sync_configs(id) ON DELETE CASCADE,

  sync_type TEXT NOT NULL, -- 'IMPORT', 'EXPORT', 'UPDATE', 'DELETE'
  direction TEXT NOT NULL, -- 'TO_GOOGLE', 'FROM_GOOGLE'

  event_id TEXT, -- Google Calendar Event ID
  appointment_id UUID REFERENCES appointments(id),

  status TEXT NOT NULL, -- 'SUCCESS', 'FAILED', 'PARTIAL'
  error_message TEXT,
  details JSONB,

  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

CREATE INDEX idx_calendar_configs_provider_id ON calendar_sync_configs(provider_id);
CREATE INDEX idx_calendar_logs_config_id ON calendar_sync_logs(config_id);
CREATE INDEX idx_calendar_logs_created_at ON calendar_sync_logs(created_at);
```

### 5. ç»è¥ç»Ÿè®¡æ±‡æ€»è¡¨ï¼ˆæ–°å¢ï¼‰

```sql
-- æ¯æ—¥è¥ä¸šæ±‡æ€»
CREATE TABLE daily_business_summary (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_id UUID NOT NULL REFERENCES provider_profiles(id) ON DELETE CASCADE,
  business_date DATE NOT NULL,

  -- é¢„çº¦ç»Ÿè®¡
  total_appointments INTEGER DEFAULT 0,
  completed_appointments INTEGER DEFAULT 0,
  cancelled_appointments INTEGER DEFAULT 0,
  no_show_appointments INTEGER DEFAULT 0,

  -- æ”¶å…¥ç»Ÿè®¡
  total_revenue DECIMAL(10, 2) DEFAULT 0,
  platform_fees DECIMAL(10, 2) DEFAULT 0,
  staff_commissions DECIMAL(10, 2) DEFAULT 0,
  net_revenue DECIMAL(10, 2) DEFAULT 0,

  -- å®¢æˆ·ç»Ÿè®¡
  total_customers INTEGER DEFAULT 0,
  new_customers INTEGER DEFAULT 0,
  returning_customers INTEGER DEFAULT 0,

  -- æœåŠ¡ç»Ÿè®¡
  services_breakdown JSONB, -- å„æœåŠ¡ç±»å‹çš„æ•°é‡å’Œæ”¶å…¥
  staff_performance JSONB, -- å„å‘˜å·¥çš„ä¸šç»©

  -- æ—¶é—´æ®µç»Ÿè®¡
  peak_hours JSONB, -- é«˜å³°æ—¶æ®µåˆ†æ
  utilization_rate DECIMAL(5, 2), -- æ—¶é—´åˆ©ç”¨ç‡

  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),

  UNIQUE(provider_id, business_date)
);

CREATE INDEX idx_daily_summary_provider_date ON daily_business_summary(provider_id, business_date);
CREATE INDEX idx_daily_summary_date ON daily_business_summary(business_date);
```

---

## ğŸ”„ Google æ—¥å†åŒå‘åŒæ­¥

### å®ç°æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BeautyBook Platform                    â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ é¢„çº¦åˆ›å»º/ä¿®æ”¹ â”‚ â”€â”€â”€â”€â”€â”€> â”‚ Webhookè§¦å‘  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                   â”‚                â”‚
â”‚                                   â–¼                â”‚
â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚                         â”‚ åŒæ­¥ä»»åŠ¡é˜Ÿåˆ—    â”‚         â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                           â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ å¯¼å‡ºåˆ°Google    â”‚         â”‚ ä»Googleå¯¼å…¥    â”‚
            â”‚ Calendar        â”‚         â”‚ Calendar        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                           â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Google Calendar API   â”‚
                    â”‚   (OAuth 2.0)          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯å®ç°

#### 1. Google Calendar API é›†æˆ

```typescript
// lib/google-calendar/client.ts
import { google } from 'googleapis';
import { prisma } from '@/lib/prisma';

export class GoogleCalendarService {
  private oauth2Client;

  constructor() {
    this.oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    );
  }

  /**
   * æˆæƒ URL ç”Ÿæˆ
   */
  getAuthUrl() {
    return this.oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: [
        'https://www.googleapis.com/auth/calendar',
        'https://www.googleapis.com/auth/calendar.events'
      ],
      prompt: 'consent'
    });
  }

  /**
   * ä¿å­˜æˆæƒä»¤ç‰Œ
   */
  async saveTokens(providerId: string, code: string) {
    const { tokens } = await this.oauth2Client.getToken(code);

    await prisma.calendarSyncConfig.upsert({
      where: { providerId },
      create: {
        providerId,
        googleCalendarId: 'primary',
        accessToken: this.encrypt(tokens.access_token!),
        refreshToken: this.encrypt(tokens.refresh_token!),
        tokenExpiry: new Date(tokens.expiry_date!),
        syncEnabled: true,
        syncDirection: 'BIDIRECTIONAL'
      },
      update: {
        accessToken: this.encrypt(tokens.access_token!),
        refreshToken: this.encrypt(tokens.refresh_token!),
        tokenExpiry: new Date(tokens.expiry_date!),
      }
    });

    return tokens;
  }

  /**
   * åˆ·æ–°è®¿é—®ä»¤ç‰Œ
   */
  async refreshAccessToken(providerId: string) {
    const config = await prisma.calendarSyncConfig.findUnique({
      where: { providerId }
    });

    if (!config) throw new Error('Calendar sync not configured');

    this.oauth2Client.setCredentials({
      refresh_token: this.decrypt(config.refreshToken)
    });

    const { credentials } = await this.oauth2Client.refreshAccessToken();

    await prisma.calendarSyncConfig.update({
      where: { providerId },
      data: {
        accessToken: this.encrypt(credentials.access_token!),
        tokenExpiry: new Date(credentials.expiry_date!)
      }
    });

    return credentials;
  }

  /**
   * å¯¼å‡ºé¢„çº¦åˆ° Google Calendar
   */
  async exportAppointmentToGoogle(appointmentId: string) {
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId },
      include: {
        customer: true,
        service: true,
        provider: true,
        staff: true
      }
    });

    if (!appointment) throw new Error('Appointment not found');

    const config = await this.getValidConfig(appointment.providerId);
    this.oauth2Client.setCredentials({
      access_token: this.decrypt(config.accessToken),
      refresh_token: this.decrypt(config.refreshToken)
    });

    const calendar = google.calendar({ version: 'v3', auth: this.oauth2Client });

    // æ„å»ºäº‹ä»¶æ•°æ®
    const eventData = {
      summary: `${appointment.service.name} - ${appointment.customer.firstName} ${appointment.customer.lastName}`,
      description: `
Service: ${appointment.service.name}
Customer: ${appointment.customer.email}
Phone: ${appointment.customer.customerProfile?.phone || 'N/A'}
Staff: ${appointment.staff?.name || 'Unassigned'}
Amount: $${appointment.amount}
Notes: ${appointment.notes || 'None'}

Booking ID: ${appointment.id}
      `.trim(),
      start: {
        dateTime: this.combineDateTime(appointment.date, appointment.startTime),
        timeZone: 'America/New_York' // æ ¹æ®å•†æˆ·æ—¶åŒºé…ç½®
      },
      end: {
        dateTime: this.combineDateTime(appointment.date, appointment.endTime),
        timeZone: 'America/New_York'
      },
      attendees: [
        { email: appointment.customer.email },
        ...(appointment.staff?.email ? [{ email: appointment.staff.email }] : [])
      ],
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 24 * 60 }, // 1 day before
          { method: 'popup', minutes: 60 }       // 1 hour before
        ]
      },
      colorId: '9' // è“è‰²ï¼Œå¯æ ¹æ®æœåŠ¡ç±»å‹è‡ªå®šä¹‰
    };

    let event;

    if (appointment.googleEventId) {
      // æ›´æ–°ç°æœ‰äº‹ä»¶
      event = await calendar.events.update({
        calendarId: config.googleCalendarId,
        eventId: appointment.googleEventId,
        requestBody: eventData
      });
    } else {
      // åˆ›å»ºæ–°äº‹ä»¶
      event = await calendar.events.insert({
        calendarId: config.googleCalendarId,
        requestBody: eventData,
        sendUpdates: 'all' // å‘é€é€šçŸ¥ç»™å‚ä¸è€…
      });

      // ä¿å­˜ Google Event ID
      await prisma.appointment.update({
        where: { id: appointmentId },
        data: { googleEventId: event.data.id }
      });
    }

    // è®°å½•åŒæ­¥æ—¥å¿—
    await this.logSync({
      configId: config.id,
      syncType: appointment.googleEventId ? 'UPDATE' : 'EXPORT',
      direction: 'TO_GOOGLE',
      eventId: event.data.id,
      appointmentId: appointment.id,
      status: 'SUCCESS'
    });

    return event.data;
  }

  /**
   * ä» Google Calendar å¯¼å…¥äº‹ä»¶
   */
  async importEventsFromGoogle(providerId: string, startDate: Date, endDate: Date) {
    const config = await this.getValidConfig(providerId);
    this.oauth2Client.setCredentials({
      access_token: this.decrypt(config.accessToken),
      refresh_token: this.decrypt(config.refreshToken)
    });

    const calendar = google.calendar({ version: 'v3', auth: this.oauth2Client });

    const response = await calendar.events.list({
      calendarId: config.googleCalendarId,
      timeMin: startDate.toISOString(),
      timeMax: endDate.toISOString(),
      singleEvents: true,
      orderBy: 'startTime'
    });

    const events = response.data.items || [];
    const imported = [];

    for (const event of events) {
      // è·³è¿‡å·²åŒæ­¥çš„äº‹ä»¶
      const existing = await prisma.appointment.findFirst({
        where: { googleEventId: event.id }
      });

      if (existing) continue;

      // æ£€æŸ¥æ˜¯å¦ä¸ºå¤–éƒ¨äº‹ä»¶ï¼ˆéå¹³å°åˆ›å»ºï¼‰
      if (!event.description?.includes('Booking ID:')) {
        if (config.autoAcceptExternal) {
          // è‡ªåŠ¨å¯¼å…¥å¤–éƒ¨äº‹ä»¶
          const appointment = await this.createAppointmentFromGoogleEvent(
            providerId,
            event
          );
          imported.push(appointment);

          await this.logSync({
            configId: config.id,
            syncType: 'IMPORT',
            direction: 'FROM_GOOGLE',
            eventId: event.id,
            appointmentId: appointment.id,
            status: 'SUCCESS'
          });
        }
      }
    }

    return imported;
  }

  /**
   * è®¾ç½® Webhook ç›‘å¬æ—¥å†å˜åŒ–
   */
  async setupWebhook(providerId: string) {
    const config = await this.getValidConfig(providerId);
    this.oauth2Client.setCredentials({
      access_token: this.decrypt(config.accessToken)
    });

    const calendar = google.calendar({ version: 'v3', auth: this.oauth2Client });

    const channelId = `beautybook-${providerId}-${Date.now()}`;
    const webhookUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/google-calendar`;

    const channel = await calendar.events.watch({
      calendarId: config.googleCalendarId,
      requestBody: {
        id: channelId,
        type: 'web_hook',
        address: webhookUrl,
        token: this.generateWebhookToken(providerId),
        expiration: Date.now() + 7 * 24 * 60 * 60 * 1000 // 7 days
      }
    });

    return channel.data;
  }

  /**
   * åˆ é™¤ Google Calendar äº‹ä»¶
   */
  async deleteGoogleEvent(appointmentId: string) {
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId },
      include: { provider: true }
    });

    if (!appointment?.googleEventId) return;

    const config = await this.getValidConfig(appointment.providerId);
    this.oauth2Client.setCredentials({
      access_token: this.decrypt(config.accessToken)
    });

    const calendar = google.calendar({ version: 'v3', auth: this.oauth2Client });

    await calendar.events.delete({
      calendarId: config.googleCalendarId,
      eventId: appointment.googleEventId,
      sendUpdates: 'all'
    });

    await this.logSync({
      configId: config.id,
      syncType: 'DELETE',
      direction: 'TO_GOOGLE',
      eventId: appointment.googleEventId,
      appointmentId: appointment.id,
      status: 'SUCCESS'
    });
  }

  // è¾…åŠ©æ–¹æ³•
  private combineDateTime(date: Date, time: string): string {
    const [hours, minutes] = time.split(':');
    const dateTime = new Date(date);
    dateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    return dateTime.toISOString();
  }

  private encrypt(text: string): string {
    // ä½¿ç”¨åŠ å¯†åº“ï¼ˆå¦‚ crypto-jsï¼‰åŠ å¯†æ•æ„Ÿä¿¡æ¯
    // å®é™…å®ç°éœ€è¦ä½¿ç”¨ç¯å¢ƒå˜é‡ä¸­çš„å¯†é’¥
    return text; // ç®€åŒ–ç¤ºä¾‹
  }

  private decrypt(text: string): string {
    return text; // ç®€åŒ–ç¤ºä¾‹
  }

  private async getValidConfig(providerId: string) {
    const config = await prisma.calendarSyncConfig.findUnique({
      where: { providerId }
    });

    if (!config) throw new Error('Calendar not synced');

    // æ£€æŸ¥ token æ˜¯å¦è¿‡æœŸ
    if (config.tokenExpiry < new Date()) {
      await this.refreshAccessToken(providerId);
      return this.getValidConfig(providerId);
    }

    return config;
  }

  private async logSync(data: any) {
    await prisma.calendarSyncLog.create({ data });
  }

  private generateWebhookToken(providerId: string): string {
    // ç”Ÿæˆå®‰å…¨çš„ webhook token
    return `beautybook_${providerId}_${Math.random().toString(36)}`;
  }

  private async createAppointmentFromGoogleEvent(
    providerId: string,
    event: any
  ) {
    // ä» Google Event åˆ›å»ºé¢„çº¦è®°å½•
    // å®ç°ç»†èŠ‚æ ¹æ®ä¸šåŠ¡éœ€æ±‚
    return null;
  }
}
```

#### 2. åå°åŒæ­¥ä»»åŠ¡

```typescript
// lib/jobs/calendar-sync-job.ts
import { GoogleCalendarService } from '@/lib/google-calendar/client';
import { prisma } from '@/lib/prisma';

export class CalendarSyncJob {
  private googleCalendar: GoogleCalendarService;

  constructor() {
    this.googleCalendar = new GoogleCalendarService();
  }

  /**
   * å®šæ—¶åŒæ­¥ä»»åŠ¡ï¼ˆæ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡ï¼‰
   */
  async syncAll() {
    const configs = await prisma.calendarSyncConfig.findMany({
      where: { syncEnabled: true }
    });

    for (const config of configs) {
      try {
        await this.syncProvider(config.providerId);
      } catch (error) {
        console.error(`Sync failed for provider ${config.providerId}:`, error);

        await prisma.calendarSyncConfig.update({
          where: { id: config.id },
          data: {
            syncErrors: {
              lastError: error.message,
              occurredAt: new Date()
            }
          }
        });
      }
    }
  }

  /**
   * åŒæ­¥å•ä¸ªå•†æˆ·
   */
  private async syncProvider(providerId: string) {
    const now = new Date();
    const startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); // 7 days ago
    const endDate = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days ahead

    // 1. å¯¼å‡ºå¹³å°é¢„çº¦åˆ° Google Calendar
    const pendingExports = await prisma.appointment.findMany({
      where: {
        providerId,
        date: { gte: startDate, lte: endDate },
        status: { in: ['SCHEDULED', 'CONFIRMED'] },
        OR: [
          { googleEventId: null },
          { updatedAt: { gte: await this.getLastSyncTime(providerId) } }
        ]
      }
    });

    for (const appointment of pendingExports) {
      await this.googleCalendar.exportAppointmentToGoogle(appointment.id);
    }

    // 2. ä» Google Calendar å¯¼å…¥å¤–éƒ¨äº‹ä»¶
    await this.googleCalendar.importEventsFromGoogle(
      providerId,
      startDate,
      endDate
    );

    // 3. æ›´æ–°æœ€ååŒæ­¥æ—¶é—´
    await prisma.calendarSyncConfig.update({
      where: { providerId },
      data: { lastSyncAt: new Date() }
    });
  }

  private async getLastSyncTime(providerId: string): Promise<Date> {
    const config = await prisma.calendarSyncConfig.findUnique({
      where: { providerId }
    });

    return config?.lastSyncAt || new Date(0);
  }
}

// Cron job é…ç½®ï¼ˆä½¿ç”¨ node-cron æˆ– Vercel Cronï¼‰
// */5 * * * * - æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
```

---

## ğŸ› ï¸ æœåŠ¡ç®¡ç†ç³»ç»Ÿ

### å•†æˆ·æœåŠ¡é…ç½®ç•Œé¢

```typescript
// app/provider-dashboard/services/page.tsx
'use client';

import { useState } from 'react';
import { Plus, Edit, Trash2, Clock, DollarSign } from 'lucide-react';

export default function ServicesManagement() {
  const [services, setServices] = useState([]);
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);

  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">æœåŠ¡é¡¹ç›®ç®¡ç†</h1>
        <button
          onClick={() => setIsAddModalOpen(true)}
          className="btn-primary flex items-center gap-2"
        >
          <Plus size={20} />
          æ·»åŠ æœåŠ¡
        </button>
      </div>

      {/* æœåŠ¡åˆ—è¡¨ */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {services.map(service => (
          <ServiceCard key={service.id} service={service} />
        ))}
      </div>

      {/* æ·»åŠ /ç¼–è¾‘æœåŠ¡æ¨¡æ€æ¡† */}
      {isAddModalOpen && (
        <ServiceModal
          onClose={() => setIsAddModalOpen(false)}
          onSave={(data) => handleSaveService(data)}
        />
      )}
    </div>
  );
}

// æœåŠ¡å¡ç‰‡ç»„ä»¶
function ServiceCard({ service }) {
  return (
    <div className="card p-4 hover:shadow-lg transition-shadow">
      <div className="flex justify-between items-start mb-3">
        <div>
          <h3 className="font-semibold text-lg">{service.name}</h3>
          <span className="badge badge-primary">{service.category}</span>
        </div>
        <div className="flex gap-2">
          <button className="p-1 hover:bg-gray-100 rounded">
            <Edit size={16} />
          </button>
          <button className="p-1 hover:bg-red-50 text-red-600 rounded">
            <Trash2 size={16} />
          </button>
        </div>
      </div>

      <p className="text-sm text-gray-600 mb-3 line-clamp-2">
        {service.description}
      </p>

      <div className="flex items-center gap-4 text-sm">
        <div className="flex items-center gap-1">
          <Clock size={16} className="text-gray-400" />
          <span>{service.duration} åˆ†é’Ÿ</span>
        </div>
        <div className="flex items-center gap-1">
          <DollarSign size={16} className="text-gray-400" />
          <span className="font-semibold">${service.price}</span>
        </div>
      </div>

      {/* å¯åˆ†é…å‘˜å·¥ */}
      <div className="mt-3 pt-3 border-t">
        <p className="text-xs text-gray-500 mb-2">å¯æä¾›æ­¤æœåŠ¡çš„å‘˜å·¥ï¼š</p>
        <div className="flex flex-wrap gap-1">
          {service.availableStaff?.map(staff => (
            <span key={staff.id} className="badge badge-sm">
              {staff.name}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
}

// æœåŠ¡ç¼–è¾‘æ¨¡æ€æ¡†
function ServiceModal({ service, onClose, onSave }) {
  const [formData, setFormData] = useState({
    name: service?.name || '',
    description: service?.description || '',
    category: service?.category || 'FACIAL',
    duration: service?.duration || 60,
    price: service?.price || 0,
    active: service?.active ?? true,
    availableStaffIds: service?.availableStaffIds || []
  });

  const handleSubmit = async (e) => {
    e.preventDefault();

    const response = await fetch('/api/provider/services', {
      method: service ? 'PUT' : 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(formData)
    });

    if (response.ok) {
      const data = await response.json();
      onSave(data);
      onClose();
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6">
          <h2 className="text-xl font-bold mb-4">
            {service ? 'ç¼–è¾‘æœåŠ¡' : 'æ·»åŠ æ–°æœåŠ¡'}
          </h2>

          <form onSubmit={handleSubmit} className="space-y-4">
            {/* æœåŠ¡åç§° */}
            <div>
              <label className="block text-sm font-medium mb-1">
                æœåŠ¡åç§° *
              </label>
              <input
                type="text"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                className="input-field w-full"
                required
              />
            </div>

            {/* æœåŠ¡åˆ†ç±» */}
            <div>
              <label className="block text-sm font-medium mb-1">
                æœåŠ¡åˆ†ç±» *
              </label>
              <select
                value={formData.category}
                onChange={(e) => setFormData({...formData, category: e.target.value})}
                className="input-field w-full"
              >
                <option value="FACIAL">é¢éƒ¨æŠ¤ç†</option>
                <option value="HAIR">ç¾å‘</option>
                <option value="MASSAGE">æŒ‰æ‘©</option>
                <option value="NAILS">ç¾ç”²</option>
                <option value="BODY">èº«ä½“æŠ¤ç†</option>
                <option value="MAKEUP">åŒ–å¦†</option>
                <option value="OTHER">å…¶ä»–</option>
              </select>
            </div>

            {/* æœåŠ¡æè¿° */}
            <div>
              <label className="block text-sm font-medium mb-1">
                æœåŠ¡æè¿°
              </label>
              <textarea
                value={formData.description}
                onChange={(e) => setFormData({...formData, description: e.target.value})}
                className="input-field w-full h-24"
                placeholder="è¯¦ç»†æè¿°æœåŠ¡å†…å®¹ã€æ•ˆæœã€é€‚ç”¨äººç¾¤ç­‰"
              />
            </div>

            {/* æ—¶é•¿å’Œä»·æ ¼ */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium mb-1">
                  æœåŠ¡æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰*
                </label>
                <input
                  type="number"
                  value={formData.duration}
                  onChange={(e) => setFormData({...formData, duration: parseInt(e.target.value)})}
                  className="input-field w-full"
                  min="15"
                  step="15"
                  required
                />
                <p className="text-xs text-gray-500 mt-1">
                  å»ºè®®è®¾ç½®ä¸º15åˆ†é’Ÿçš„å€æ•°
                </p>
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">
                  æœåŠ¡ä»·æ ¼ï¼ˆUSDï¼‰*
                </label>
                <input
                  type="number"
                  value={formData.price}
                  onChange={(e) => setFormData({...formData, price: parseFloat(e.target.value)})}
                  className="input-field w-full"
                  min="0"
                  step="0.01"
                  required
                />
              </div>
            </div>

            {/* å¯æä¾›æ­¤æœåŠ¡çš„å‘˜å·¥ */}
            <div>
              <label className="block text-sm font-medium mb-2">
                æŒ‡å®šå¯æä¾›æ­¤æœåŠ¡çš„å‘˜å·¥
              </label>
              <StaffSelector
                selectedIds={formData.availableStaffIds}
                onChange={(ids) => setFormData({...formData, availableStaffIds: ids})}
              />
            </div>

            {/* çŠ¶æ€ */}
            <div className="flex items-center">
              <input
                type="checkbox"
                id="active"
                checked={formData.active}
                onChange={(e) => setFormData({...formData, active: e.target.checked})}
                className="mr-2"
              />
              <label htmlFor="active" className="text-sm">
                ç«‹å³å¯ç”¨æ­¤æœåŠ¡
              </label>
            </div>

            {/* æŒ‰é’® */}
            <div className="flex justify-end gap-3 pt-4">
              <button
                type="button"
                onClick={onClose}
                className="btn-secondary"
              >
                å–æ¶ˆ
              </button>
              <button type="submit" className="btn-primary">
                ä¿å­˜
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}
```

### API å®ç°

```typescript
// app/api/provider/services/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { auth } from '@clerk/nextjs';

export async function GET(req: NextRequest) {
  const { userId } = auth();

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // è·å–å•†æˆ· ID
  const provider = await prisma.providerProfile.findFirst({
    where: { user: { clerkId: userId } }
  });

  if (!provider) {
    return NextResponse.json({ error: 'Provider not found' }, { status: 404 });
  }

  const services = await prisma.service.findMany({
    where: { providerId: provider.id },
    orderBy: { createdAt: 'desc' }
  });

  return NextResponse.json(services);
}

export async function POST(req: NextRequest) {
  const { userId } = auth();

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const provider = await prisma.providerProfile.findFirst({
    where: { user: { clerkId: userId } }
  });

  if (!provider) {
    return NextResponse.json({ error: 'Provider not found' }, { status: 404 });
  }

  const data = await req.json();

  const service = await prisma.service.create({
    data: {
      providerId: provider.id,
      name: data.name,
      description: data.description,
      category: data.category,
      duration: data.duration,
      price: data.price,
      active: data.active
    }
  });

  return NextResponse.json(service, { status: 201 });
}
```

---

## ğŸ‘¥ åº—å‘˜æ´¾å•ç³»ç»Ÿ

### æ™ºèƒ½æ´¾å•ç®—æ³•

```typescript
// lib/dispatch/staff-assignment.ts
import { prisma } from '@/lib/prisma';

export class StaffAssignmentService {
  /**
   * æ™ºèƒ½æ´¾å• - ä¸ºé¢„çº¦åˆ†é…æœ€åˆé€‚çš„å‘˜å·¥
   */
  async autoAssignStaff(appointmentId: string) {
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId },
      include: {
        service: true,
        provider: true
      }
    });

    if (!appointment) throw new Error('Appointment not found');

    // è·å–æ‰€æœ‰å¯ç”¨å‘˜å·¥
    const availableStaff = await this.getAvailableStaff(
      appointment.providerId,
      appointment.date,
      appointment.startTime,
      appointment.endTime,
      appointment.service.category
    );

    if (availableStaff.length === 0) {
      throw new Error('No available staff for this time slot');
    }

    // è¯„åˆ†å¹¶é€‰æ‹©æœ€ä½³å‘˜å·¥
    const scoredStaff = availableStaff.map(staff => ({
      staff,
      score: this.calculateStaffScore(staff, appointment)
    }));

    // æŒ‰åˆ†æ•°æ’åº
    scoredStaff.sort((a, b) => b.score - a.score);

    const bestStaff = scoredStaff[0].staff;

    // åˆ†é…å‘˜å·¥
    await prisma.appointment.update({
      where: { id: appointmentId },
      data: {
        staffId: bestStaff.id,
        assignmentType: 'AUTO',
        assignedAt: new Date()
      }
    });

    return bestStaff;
  }

  /**
   * æ‰‹åŠ¨æ´¾å•
   */
  async manualAssignStaff(appointmentId: string, staffId: string, assignedBy: string) {
    // æ£€æŸ¥å‘˜å·¥æ˜¯å¦å¯ç”¨
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId }
    });

    const isAvailable = await this.checkStaffAvailability(
      staffId,
      appointment!.date,
      appointment!.startTime,
      appointment!.endTime
    );

    if (!isAvailable) {
      throw new Error('Staff is not available at this time');
    }

    await prisma.appointment.update({
      where: { id: appointmentId },
      data: {
        staffId,
        assignmentType: 'MANUAL',
        assignedAt: new Date(),
        assignedBy
      }
    });
  }

  /**
   * è·å–å¯ç”¨å‘˜å·¥åˆ—è¡¨
   */
  private async getAvailableStaff(
    providerId: string,
    date: Date,
    startTime: string,
    endTime: string,
    serviceCategory: string
  ) {
    // è·å–æ‰€æœ‰æ¿€æ´»çŠ¶æ€çš„å‘˜å·¥
    const allStaff = await prisma.staffMember.findMany({
      where: {
        providerId,
        status: 'ACTIVE',
        specialties: {
          has: serviceCategory
        }
      }
    });

    // è¿‡æ»¤å‡ºåœ¨è¯¥æ—¶é—´æ®µå¯ç”¨çš„å‘˜å·¥
    const availableStaff = [];

    for (const staff of allStaff) {
      const isAvailable = await this.checkStaffAvailability(
        staff.id,
        date,
        startTime,
        endTime
      );

      if (isAvailable) {
        availableStaff.push(staff);
      }
    }

    return availableStaff;
  }

  /**
   * æ£€æŸ¥å‘˜å·¥åœ¨æŒ‡å®šæ—¶é—´æ˜¯å¦å¯ç”¨
   */
  private async checkStaffAvailability(
    staffId: string,
    date: Date,
    startTime: string,
    endTime: string
  ): Promise<boolean> {
    // 1. æ£€æŸ¥å·¥ä½œæ—¶é—´
    const staff = await prisma.staffMember.findUnique({
      where: { id: staffId }
    });

    if (!staff) return false;

    const dayOfWeek = date.getDay();
    const workSchedule = staff.workSchedule as any;

    if (!workSchedule[dayOfWeek]?.working) {
      return false;
    }

    const { start, end } = workSchedule[dayOfWeek];
    if (startTime < start || endTime > end) {
      return false;
    }

    // 2. æ£€æŸ¥æ˜¯å¦æœ‰å†²çªçš„é¢„çº¦
    const conflicts = await prisma.appointment.findMany({
      where: {
        staffId,
        date,
        status: { in: ['SCHEDULED', 'CONFIRMED'] },
        OR: [
          {
            AND: [
              { startTime: { lte: startTime } },
              { endTime: { gt: startTime } }
            ]
          },
          {
            AND: [
              { startTime: { lt: endTime } },
              { endTime: { gte: endTime } }
            ]
          },
          {
            AND: [
              { startTime: { gte: startTime } },
              { endTime: { lte: endTime } }
            ]
          }
        ]
      }
    });

    return conflicts.length === 0;
  }

  /**
   * è®¡ç®—å‘˜å·¥åŒ¹é…åˆ†æ•°
   * ç»¼åˆè€ƒè™‘ï¼šæŠ€èƒ½æ°´å¹³ã€å½“æ—¥å·¥ä½œé‡ã€å†å²è¯„åˆ†ã€å®¢æˆ·åå¥½ç­‰
   */
  private calculateStaffScore(staff: any, appointment: any): number {
    let score = 0;

    // 1. æŠ€èƒ½æ°´å¹³ (0-30åˆ†)
    const skillLevelScores = {
      'EXPERT': 30,
      'SENIOR': 25,
      'INTERMEDIATE': 20,
      'JUNIOR': 15
    };
    score += skillLevelScores[staff.skillLevel] || 0;

    // 2. å†å²è¯„åˆ† (0-25åˆ†)
    score += (staff.averageRating / 5) * 25;

    // 3. å·¥ä½œé‡å¹³è¡¡ (0-20åˆ†)
    // å½“æ—¥é¢„çº¦æ•°è¶Šå°‘ï¼Œåˆ†æ•°è¶Šé«˜ï¼ˆå¹³è¡¡å·¥ä½œé‡ï¼‰
    const dailyAppointments = staff._count?.appointments || 0;
    score += Math.max(0, 20 - dailyAppointments * 2);

    // 4. ä¸“ä¸šåŒ¹é…åº¦ (0-15åˆ†)
    const isPrimarySpecialty = staff.specialties[0] === appointment.service.category;
    score += isPrimarySpecialty ? 15 : 10;

    // 5. å®¢æˆ·åå¥½ (0-10åˆ†)
    // å¦‚æœå®¢æˆ·ä¹‹å‰é€‰æ‹©è¿‡æ­¤å‘˜å·¥ï¼ŒåŠ åˆ†
    const isPreferredStaff = false; // å®é™…éœ€æŸ¥è¯¢å†å²
    score += isPreferredStaff ? 10 : 0;

    return score;
  }

  /**
   * æ‰¹é‡æ´¾å• - ä¸ºä¸€å¤©çš„æ‰€æœ‰å¾…æ´¾å•é¢„çº¦åˆ†é…å‘˜å·¥
   */
  async batchAssign(providerId: string, date: Date) {
    const unassignedAppointments = await prisma.appointment.findMany({
      where: {
        providerId,
        date,
        staffId: null,
        status: { in: ['SCHEDULED', 'CONFIRMED'] }
      },
      orderBy: { startTime: 'asc' }
    });

    const results = [];

    for (const appointment of unassignedAppointments) {
      try {
        const staff = await this.autoAssignStaff(appointment.id);
        results.push({ appointmentId: appointment.id, staffId: staff.id, success: true });
      } catch (error) {
        results.push({ appointmentId: appointment.id, error: error.message, success: false });
      }
    }

    return results;
  }
}
```

### æ´¾å•ç•Œé¢

```typescript
// app/provider-dashboard/dispatch/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { Calendar, User, Clock, AlertCircle } from 'lucide-react';

export default function DispatchManagement() {
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [appointments, setAppointments] = useState([]);
  const [staff, setStaff] = useState([]);

  useEffect(() => {
    loadAppointments(selectedDate);
    loadStaff();
  }, [selectedDate]);

  const loadAppointments = async (date: Date) => {
    const response = await fetch(
      `/api/provider/appointments?date=${date.toISOString().split('T')[0]}`
    );
    const data = await response.json();
    setAppointments(data);
  };

  const handleAutoAssign = async (appointmentId: string) => {
    const response = await fetch('/api/provider/dispatch/auto-assign', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ appointmentId })
    });

    if (response.ok) {
      await loadAppointments(selectedDate);
    }
  };

  const handleManualAssign = async (appointmentId: string, staffId: string) => {
    const response = await fetch('/api/provider/dispatch/manual-assign', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ appointmentId, staffId })
    });

    if (response.ok) {
      await loadAppointments(selectedDate);
    }
  };

  const handleBatchAssign = async () => {
    const response = await fetch('/api/provider/dispatch/batch-assign', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ date: selectedDate })
    });

    if (response.ok) {
      await loadAppointments(selectedDate);
    }
  };

  return (
    <div className="p-6">
      {/* å¤´éƒ¨ */}
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">åº—å‘˜æ´¾å•</h1>
        <div className="flex gap-3">
          <input
            type="date"
            value={selectedDate.toISOString().split('T')[0]}
            onChange={(e) => setSelectedDate(new Date(e.target.value))}
            className="input-field"
          />
          <button
            onClick={handleBatchAssign}
            className="btn-primary"
          >
            ä¸€é”®æ™ºèƒ½æ´¾å•
          </button>
        </div>
      </div>

      {/* ç»Ÿè®¡å¡ç‰‡ */}
      <div className="grid grid-cols-4 gap-4 mb-6">
        <StatCard
          title="å¾…æ´¾å•"
          value={appointments.filter(a => !a.staffId).length}
          icon={<AlertCircle />}
          color="orange"
        />
        <StatCard
          title="å·²æ´¾å•"
          value={appointments.filter(a => a.staffId).length}
          icon={<User />}
          color="green"
        />
        <StatCard
          title="æ€»é¢„çº¦"
          value={appointments.length}
          icon={<Calendar />}
          color="blue"
        />
        <StatCard
          title="åœ¨å²—å‘˜å·¥"
          value={staff.filter(s => s.status === 'ACTIVE').length}
          icon={<User />}
          color="purple"
        />
      </div>

      {/* æ´¾å•é¢æ¿ */}
      <div className="grid grid-cols-3 gap-6">
        {/* å·¦ä¾§ï¼šå¾…æ´¾å•åˆ—è¡¨ */}
        <div className="col-span-2">
          <h2 className="font-semibold text-lg mb-4">é¢„çº¦åˆ—è¡¨</h2>
          <div className="space-y-3">
            {appointments.map(appointment => (
              <AppointmentCard
                key={appointment.id}
                appointment={appointment}
                staff={staff}
                onAutoAssign={() => handleAutoAssign(appointment.id)}
                onManualAssign={(staffId) => handleManualAssign(appointment.id, staffId)}
              />
            ))}
          </div>
        </div>

        {/* å³ä¾§ï¼šå‘˜å·¥çŠ¶æ€ */}
        <div>
          <h2 className="font-semibold text-lg mb-4">å‘˜å·¥çŠ¶æ€</h2>
          <div className="space-y-3">
            {staff.map(member => (
              <StaffStatusCard
                key={member.id}
                staff={member}
                appointments={appointments.filter(a => a.staffId === member.id)}
              />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

// é¢„çº¦å¡ç‰‡
function AppointmentCard({ appointment, staff, onAutoAssign, onManualAssign }) {
  const [isAssigning, setIsAssigning] = useState(false);

  return (
    <div className={`card p-4 ${!appointment.staffId ? 'border-2 border-orange-300' : ''}`}>
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            <Clock size={16} className="text-gray-400" />
            <span className="font-semibold">
              {appointment.startTime} - {appointment.endTime}
            </span>
            {!appointment.staffId && (
              <span className="badge badge-orange">å¾…æ´¾å•</span>
            )}
          </div>

          <p className="text-sm mb-1">
            <strong>å®¢æˆ·ï¼š</strong>{appointment.customer.firstName} {appointment.customer.lastName}
          </p>
          <p className="text-sm mb-1">
            <strong>æœåŠ¡ï¼š</strong>{appointment.service.name}
          </p>
          <p className="text-sm text-gray-600">
            <strong>æ—¶é•¿ï¼š</strong>{appointment.service.duration} åˆ†é’Ÿ |
            <strong>é‡‘é¢ï¼š</strong>${appointment.amount}
          </p>

          {appointment.staff && (
            <div className="mt-2 flex items-center gap-2">
              <div className="w-8 h-8 rounded-full bg-primary-100 flex items-center justify-center">
                <User size={16} />
              </div>
              <span className="text-sm font-medium">{appointment.staff.name}</span>
              <span className="badge badge-sm badge-green">å·²æ´¾å•</span>
            </div>
          )}
        </div>

        {!appointment.staffId && (
          <div className="flex flex-col gap-2">
            <button
              onClick={onAutoAssign}
              className="btn-sm btn-primary"
            >
              æ™ºèƒ½æ´¾å•
            </button>
            <button
              onClick={() => setIsAssigning(true)}
              className="btn-sm btn-secondary"
            >
              æ‰‹åŠ¨æŒ‡å®š
            </button>
          </div>
        )}
      </div>

      {/* æ‰‹åŠ¨æ´¾å•ä¸‹æ‹‰ */}
      {isAssigning && (
        <div className="mt-3 pt-3 border-t">
          <p className="text-sm mb-2">é€‰æ‹©å‘˜å·¥ï¼š</p>
          <select
            onChange={(e) => {
              onManualAssign(e.target.value);
              setIsAssigning(false);
            }}
            className="input-field w-full"
          >
            <option value="">è¯·é€‰æ‹©...</option>
            {staff
              .filter(s => s.specialties.includes(appointment.service.category))
              .map(s => (
                <option key={s.id} value={s.id}>
                  {s.name} - {s.skillLevel}
                </option>
              ))
            }
          </select>
        </div>
      )}
    </div>
  );
}

// å‘˜å·¥çŠ¶æ€å¡ç‰‡
function StaffStatusCard({ staff, appointments }) {
  const workload = appointments.length;
  const totalDuration = appointments.reduce((sum, a) => sum + a.service.duration, 0);

  return (
    <div className="card p-4">
      <div className="flex items-center gap-3 mb-3">
        <div className="w-12 h-12 rounded-full bg-primary-100 flex items-center justify-center">
          <User size={20} />
        </div>
        <div>
          <p className="font-semibold">{staff.name}</p>
          <p className="text-xs text-gray-500">{staff.position}</p>
        </div>
      </div>

      <div className="space-y-2 text-sm">
        <div className="flex justify-between">
          <span className="text-gray-600">ä»Šæ—¥é¢„çº¦ï¼š</span>
          <span className="font-semibold">{workload} å•</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-600">å·¥ä½œæ—¶é•¿ï¼š</span>
          <span className="font-semibold">{Math.floor(totalDuration / 60)}h {totalDuration % 60}m</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-600">å¹³å‡è¯„åˆ†ï¼š</span>
          <span className="font-semibold">â­ {staff.averageRating.toFixed(1)}</span>
        </div>
      </div>

      {/* å·¥ä½œé‡è¿›åº¦æ¡ */}
      <div className="mt-3">
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className={`h-2 rounded-full ${
              workload > 8 ? 'bg-red-500' : workload > 5 ? 'bg-yellow-500' : 'bg-green-500'
            }`}
            style={{ width: `${Math.min(100, (workload / 10) * 100)}%` }}
          />
        </div>
        <p className="text-xs text-gray-500 mt-1">
          å·¥ä½œè´Ÿè·ï¼š{workload > 8 ? 'è¾ƒé«˜' : workload > 5 ? 'ä¸­ç­‰' : 'æ­£å¸¸'}
        </p>
      </div>
    </div>
  );
}
```

---

## ğŸ’° è´¢åŠ¡æ ¸ç®—ç³»ç»Ÿ

### è‡ªåŠ¨ææˆè®¡ç®—

```typescript
// lib/finance/commission-calculator.ts
import { prisma } from '@/lib/prisma';

export class CommissionCalculator {
  /**
   * è®¡ç®—å•ç¬”é¢„çº¦çš„ææˆ
   */
  async calculateCommission(appointmentId: string) {
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId },
      include: {
        staff: true,
        service: true,
        provider: true
      }
    });

    if (!appointment || !appointment.staff) {
      throw new Error('Appointment or staff not found');
    }

    const staff = appointment.staff;
    const serviceAmount = appointment.amount;

    let staffCommission = 0;
    let calculationMethod = staff.commissionType;
    let calculationDetails: any = {};

    switch (staff.commissionType) {
      case 'PERCENTAGE':
        // ç™¾åˆ†æ¯”ææˆ
        staffCommission = serviceAmount * (staff.commissionRate! / 100);
        calculationDetails = {
          rate: staff.commissionRate,
          amount: serviceAmount,
          formula: `${serviceAmount} Ã— ${staff.commissionRate}%`
        };
        break;

      case 'FIXED':
        // å›ºå®šé‡‘é¢ææˆ
        staffCommission = staff.commissionFixed!;
        calculationDetails = {
          fixedAmount: staff.commissionFixed
        };
        break;

      case 'TIERED':
        // é˜¶æ¢¯ææˆï¼ˆæ ¹æ®å½“æœˆç´¯è®¡é‡‘é¢ï¼‰
        const monthlyTotal = await this.getMonthlyRevenue(
          staff.id,
          new Date(appointment.date)
        );

        const tiers = staff.commissionTiers as any[];
        let applicableTier = tiers[0];

        for (const tier of tiers) {
          if (monthlyTotal >= tier.threshold) {
            applicableTier = tier;
          }
        }

        staffCommission = serviceAmount * (applicableTier.rate / 100);
        calculationDetails = {
          monthlyTotal,
          tier: applicableTier,
          rate: applicableTier.rate,
          formula: `${serviceAmount} Ã— ${applicableTier.rate}%`
        };
        break;
    }

    // å¹³å°æŠ½æˆï¼ˆå‡è®¾10%ï¼‰
    const platformFeeRate = 0.10;
    const platformFee = serviceAmount * platformFeeRate;

    // å•†æˆ·å®é™…æ”¶å…¥
    const providerRevenue = serviceAmount - platformFee - staffCommission;

    // åˆ›å»ºè´¢åŠ¡è®°å½•
    const transaction = await prisma.financialTransaction.create({
      data: {
        providerId: appointment.providerId,
        appointmentId: appointment.id,
        staffId: staff.id,
        transactionType: 'REVENUE',
        amount: serviceAmount,
        serviceAmount,
        platformFee,
        staffCommission,
        providerRevenue,
        commissionRate: staff.commissionRate,
        calculationMethod,
        calculationDetails,
        settlementStatus: 'PENDING'
      }
    });

    return transaction;
  }

  /**
   * è·å–å‘˜å·¥å½“æœˆç´¯è®¡æ”¶å…¥ï¼ˆç”¨äºé˜¶æ¢¯ææˆï¼‰
   */
  private async getMonthlyRevenue(staffId: string, date: Date): Promise<number> {
    const startOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
    const endOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);

    const result = await prisma.financialTransaction.aggregate({
      where: {
        staffId,
        createdAt: {
          gte: startOfMonth,
          lte: endOfMonth
        },
        transactionType: 'REVENUE'
      },
      _sum: {
        serviceAmount: true
      }
    });

    return result._sum.serviceAmount || 0;
  }

  /**
   * æ‰¹é‡ç»“ç®— - ä¸ºå‘˜å·¥ç»“ç®—æŸä¸ªå‘¨æœŸçš„ææˆ
   */
  async settleBatch(staffId: string, startDate: Date, endDate: Date) {
    const transactions = await prisma.financialTransaction.findMany({
      where: {
        staffId,
        createdAt: { gte: startDate, lte: endDate },
        settlementStatus: 'PENDING',
        transactionType: 'COMMISSION'
      }
    });

    const totalCommission = transactions.reduce(
      (sum, t) => sum + t.staffCommission!,
      0
    );

    // æ›´æ–°æ‰€æœ‰äº¤æ˜“ä¸ºå·²ç»“ç®—
    await prisma.financialTransaction.updateMany({
      where: {
        id: { in: transactions.map(t => t.id) }
      },
      data: {
        settlementStatus: 'SETTLED',
        settledAt: new Date()
      }
    });

    return {
      staffId,
      period: { start: startDate, end: endDate },
      transactionCount: transactions.length,
      totalCommission
    };
  }
}
```

### è´¢åŠ¡ç®¡ç†ç•Œé¢

```typescript
// app/provider-dashboard/finance/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { DollarSign, TrendingUp, Users, Calendar } from 'lucide-react';

export default function FinanceManagement() {
  const [period, setPeriod] = useState('today');
  const [summary, setSummary] = useState(null);
  const [transactions, setTransactions] = useState([]);

  useEffect(() => {
    loadFinancialData(period);
  }, [period]);

  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">è´¢åŠ¡ç®¡ç†</h1>
        <select
          value={period}
          onChange={(e) => setPeriod(e.target.value)}
          className="input-field"
        >
          <option value="today">ä»Šæ—¥</option>
          <option value="week">æœ¬å‘¨</option>
          <option value="month">æœ¬æœˆ</option>
          <option value="quarter">æœ¬å­£åº¦</option>
          <option value="year">ä»Šå¹´</option>
        </select>
      </div>

      {/* è´¢åŠ¡æ¦‚è§ˆå¡ç‰‡ */}
      <div className="grid grid-cols-4 gap-4 mb-6">
        <FinanceCard
          title="æ€»æ”¶å…¥"
          value={summary?.totalRevenue || 0}
          change="+12.5%"
          icon={<DollarSign />}
          color="green"
        />
        <FinanceCard
          title="å¹³å°æŠ½æˆ"
          value={summary?.platformFees || 0}
          percentage={(summary?.platformFees / summary?.totalRevenue * 100) || 0}
          icon={<TrendingUp />}
          color="orange"
        />
        <FinanceCard
          title="å‘˜å·¥ææˆ"
          value={summary?.staffCommissions || 0}
          percentage={(summary?.staffCommissions / summary?.totalRevenue * 100) || 0}
          icon={<Users />}
          color="blue"
        />
        <FinanceCard
          title="å‡€æ”¶å…¥"
          value={summary?.netRevenue || 0}
          percentage={(summary?.netRevenue / summary?.totalRevenue * 100) || 0}
          icon={<Calendar />}
          color="purple"
        />
      </div>

      {/* Tabs */}
      <div className="card">
        <div className="border-b">
          <nav className="flex gap-4 px-6">
            <Tab active>äº¤æ˜“è®°å½•</Tab>
            <Tab>å‘˜å·¥ææˆ</Tab>
            <Tab>å¾…ç»“ç®—</Tab>
            <Tab>æŠ¥è¡¨</Tab>
          </nav>
        </div>

        <div className="p-6">
          {/* äº¤æ˜“è®°å½•è¡¨æ ¼ */}
          <TransactionTable transactions={transactions} />
        </div>
      </div>
    </div>
  );
}

function TransactionTable({ transactions }) {
  return (
    <table className="w-full">
      <thead>
        <tr className="border-b">
          <th className="text-left py-3">æ—¥æœŸæ—¶é—´</th>
          <th className="text-left py-3">é¢„çº¦å•å·</th>
          <th className="text-left py-3">å®¢æˆ·</th>
          <th className="text-left py-3">æœåŠ¡</th>
          <th className="text-left py-3">å‘˜å·¥</th>
          <th className="text-right py-3">æœåŠ¡é‡‘é¢</th>
          <th className="text-right py-3">å‘˜å·¥ææˆ</th>
          <th className="text-right py-3">å•†æˆ·æ”¶å…¥</th>
          <th className="text-center py-3">çŠ¶æ€</th>
        </tr>
      </thead>
      <tbody>
        {transactions.map(tx => (
          <tr key={tx.id} className="border-b hover:bg-gray-50">
            <td className="py-3">{new Date(tx.createdAt).toLocaleString()}</td>
            <td className="py-3 font-mono text-sm">{tx.appointment.id.slice(0, 8)}</td>
            <td className="py-3">{tx.appointment.customer.firstName}</td>
            <td className="py-3">{tx.appointment.service.name}</td>
            <td className="py-3">{tx.staff.name}</td>
            <td className="py-3 text-right font-semibold">${tx.serviceAmount.toFixed(2)}</td>
            <td className="py-3 text-right text-orange-600">${tx.staffCommission.toFixed(2)}</td>
            <td className="py-3 text-right text-green-600 font-semibold">${tx.providerRevenue.toFixed(2)}</td>
            <td className="py-3 text-center">
              <span className={`badge ${
                tx.settlementStatus === 'SETTLED' ? 'badge-green' : 'badge-yellow'
              }`}>
                {tx.settlementStatus === 'SETTLED' ? 'å·²ç»“ç®—' : 'å¾…ç»“ç®—'}
              </span>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

---

## ğŸ“Š ç»è¥çœ‹æ¿

### æ•°æ®ç»Ÿè®¡æœåŠ¡

```typescript
// lib/analytics/business-analytics.ts
import { prisma } from '@/lib/prisma';

export class BusinessAnalytics {
  /**
   * ç”Ÿæˆæ¯æ—¥è¥ä¸šæ±‡æ€»
   */
  async generateDailySummary(providerId: string, date: Date) {
    const startOfDay = new Date(date.setHours(0, 0, 0, 0));
    const endOfDay = new Date(date.setHours(23, 59, 59, 999));

    // è·å–å½“æ—¥æ‰€æœ‰é¢„çº¦
    const appointments = await prisma.appointment.findMany({
      where: {
        providerId,
        date: {
          gte: startOfDay,
          lte: endOfDay
        }
      },
      include: {
        service: true,
        staff: true,
        customer: true
      }
    });

    // é¢„çº¦ç»Ÿè®¡
    const totalAppointments = appointments.length;
    const completedAppointments = appointments.filter(a => a.status === 'COMPLETED').length;
    const cancelledAppointments = appointments.filter(a => a.status === 'CANCELLED').length;
    const noShowAppointments = appointments.filter(a => a.status === 'NO_SHOW').length;

    // æ”¶å…¥ç»Ÿè®¡
    const completedRevenue = appointments
      .filter(a => a.status === 'COMPLETED')
      .reduce((sum, a) => sum + a.amount, 0);

    const financialData = await prisma.financialTransaction.aggregate({
      where: {
        providerId,
        createdAt: {
          gte: startOfDay,
          lte: endOfDay
        }
      },
      _sum: {
        platformFee: true,
        staffCommission: true,
        providerRevenue: true
      }
    });

    // å®¢æˆ·ç»Ÿè®¡
    const customerIds = appointments.map(a => a.customerId);
    const uniqueCustomers = new Set(customerIds).size;

    const newCustomers = await prisma.appointment.count({
      where: {
        customerId: { in: Array.from(customerIds) },
        createdAt: { lt: startOfDay }
      }
    });

    // æœåŠ¡ç»Ÿè®¡
    const servicesBreakdown = {};
    for (const apt of appointments.filter(a => a.status === 'COMPLETED')) {
      const serviceName = apt.service.name;
      if (!servicesBreakdown[serviceName]) {
        servicesBreakdown[serviceName] = {
          count: 0,
          revenue: 0,
          duration: apt.service.duration
        };
      }
      servicesBreakdown[serviceName].count++;
      servicesBreakdown[serviceName].revenue += apt.amount;
    }

    // å‘˜å·¥ä¸šç»©
    const staffPerformance = {};
    for (const apt of appointments.filter(a => a.status === 'COMPLETED' && a.staff)) {
      const staffName = apt.staff.name;
      if (!staffPerformance[staffName]) {
        staffPerformance[staffName] = {
          appointments: 0,
          revenue: 0,
          commission: 0
        };
      }
      staffPerformance[staffName].appointments++;
      staffPerformance[staffName].revenue += apt.amount;
    }

    // æ·»åŠ ææˆæ•°æ®
    const commissions = await prisma.financialTransaction.findMany({
      where: {
        providerId,
        createdAt: { gte: startOfDay, lte: endOfDay },
        transactionType: 'REVENUE'
      },
      include: { staff: true }
    });

    for (const comm of commissions) {
      if (comm.staff && staffPerformance[comm.staff.name]) {
        staffPerformance[comm.staff.name].commission += comm.staffCommission || 0;
      }
    }

    // æ—¶é—´æ®µåˆ†æ
    const peakHours = this.analyzePeakHours(appointments);

    // è®¡ç®—æ—¶é—´åˆ©ç”¨ç‡
    const totalAvailableMinutes = 10 * 60; // å‡è®¾è¥ä¸š10å°æ—¶
    const totalServiceMinutes = appointments
      .filter(a => a.status === 'COMPLETED')
      .reduce((sum, a) => sum + a.service.duration, 0);
    const utilizationRate = (totalServiceMinutes / totalAvailableMinutes) * 100;

    // ä¿å­˜æ±‡æ€»æ•°æ®
    const summary = await prisma.dailyBusinessSummary.upsert({
      where: {
        providerId_businessDate: {
          providerId,
          businessDate: startOfDay
        }
      },
      create: {
        providerId,
        businessDate: startOfDay,
        totalAppointments,
        completedAppointments,
        cancelledAppointments,
        noShowAppointments,
        totalRevenue: completedRevenue,
        platformFees: financialData._sum.platformFee || 0,
        staffCommissions: financialData._sum.staffCommission || 0,
        netRevenue: financialData._sum.providerRevenue || 0,
        totalCustomers: uniqueCustomers,
        newCustomers: uniqueCustomers - newCustomers,
        returningCustomers: newCustomers,
        servicesBreakdown,
        staffPerformance,
        peakHours,
        utilizationRate
      },
      update: {
        totalAppointments,
        completedAppointments,
        cancelledAppointments,
        noShowAppointments,
        totalRevenue: completedRevenue,
        platformFees: financialData._sum.platformFee || 0,
        staffCommissions: financialData._sum.staffCommission || 0,
        netRevenue: financialData._sum.providerRevenue || 0,
        totalCustomers: uniqueCustomers,
        newCustomers: uniqueCustomers - newCustomers,
        returningCustomers: newCustomers,
        servicesBreakdown,
        staffPerformance,
        peakHours,
        utilizationRate
      }
    });

    return summary;
  }

  /**
   * åˆ†æé«˜å³°æ—¶æ®µ
   */
  private analyzePeakHours(appointments: any[]) {
    const hourlyCount = {};

    for (const apt of appointments) {
      const hour = parseInt(apt.startTime.split(':')[0]);
      hourlyCount[hour] = (hourlyCount[hour] || 0) + 1;
    }

    return Object.entries(hourlyCount)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([hour, count]) => ({
        hour: `${hour}:00`,
        appointments: count
      }));
  }

  /**
   * è·å–ç»è¥è¶‹åŠ¿ï¼ˆå‘¨/æœˆ/å¹´å¯¹æ¯”ï¼‰
   */
  async getTrends(providerId: string, period: 'week' | 'month' | 'year') {
    const now = new Date();
    let startDate: Date;
    let groupBy: string;

    switch (period) {
      case 'week':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        groupBy = 'day';
        break;
      case 'month':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        groupBy = 'day';
        break;
      case 'year':
        startDate = new Date(now.getFullYear(), 0, 1);
        groupBy = 'month';
        break;
    }

    const summaries = await prisma.dailyBusinessSummary.findMany({
      where: {
        providerId,
        businessDate: { gte: startDate }
      },
      orderBy: { businessDate: 'asc' }
    });

    return summaries;
  }
}
```

### ç»è¥çœ‹æ¿ç•Œé¢

```typescript
// app/provider-dashboard/page.tsx
'use client';

import { useState, useEffect } from 'react';
import {
  BarChart, Bar, LineChart, Line, PieChart, Pie,
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell
} from 'recharts';

export default function DashboardOverview() {
  const [summary, setSummary] = useState(null);
  const [trends, setTrends] = useState([]);
  const [period, setPeriod] = useState('today');

  useEffect(() => {
    loadDashboardData(period);
  }, [period]);

  return (
    <div className="p-6 space-y-6">
      {/* å¤´éƒ¨ */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold">ç»è¥çœ‹æ¿</h1>
          <p className="text-gray-600">
            å®æ—¶ç›‘æ§åº—é“ºè¿è¥æ•°æ®
          </p>
        </div>
        <select
          value={period}
          onChange={(e) => setPeriod(e.target.value)}
          className="input-field"
        >
          <option value="today">ä»Šæ—¥</option>
          <option value="week">æœ¬å‘¨</option>
          <option value="month">æœ¬æœˆ</option>
        </select>
      </div>

      {/* å…³é”®æŒ‡æ ‡å¡ç‰‡ */}
      <div className="grid grid-cols-5 gap-4">
        <MetricCard
          title="è¥ä¸šé¢"
          value={`$${summary?.totalRevenue?.toFixed(0) || 0}`}
          change="+15.3%"
          trend="up"
        />
        <MetricCard
          title="é¢„çº¦æ•°"
          value={summary?.totalAppointments || 0}
          change="+8.1%"
          trend="up"
        />
        <MetricCard
          title="å®Œæˆç‡"
          value={`${((summary?.completedAppointments / summary?.totalAppointments) * 100).toFixed(1)}%`}
          change="+2.5%"
          trend="up"
        />
        <MetricCard
          title="å®¢æˆ·æ•°"
          value={summary?.totalCustomers || 0}
          change="+12.0%"
          trend="up"
        />
        <MetricCard
          title="åˆ©ç”¨ç‡"
          value={`${summary?.utilizationRate?.toFixed(1) || 0}%`}
          change="-3.2%"
          trend="down"
        />
      </div>

      {/* å›¾è¡¨åŒºåŸŸ */}
      <div className="grid grid-cols-2 gap-6">
        {/* æ”¶å…¥è¶‹åŠ¿ */}
        <div className="card p-6">
          <h3 className="font-semibold text-lg mb-4">æ”¶å…¥è¶‹åŠ¿</h3>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={trends}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Line type="monotone" dataKey="totalRevenue" stroke="#8884d8" name="æ€»æ”¶å…¥" />
              <Line type="monotone" dataKey="netRevenue" stroke="#82ca9d" name="å‡€æ”¶å…¥" />
            </LineChart>
          </ResponsiveContainer>
        </div>

        {/* æœåŠ¡åˆ†å¸ƒ */}
        <div className="card p-6">
          <h3 className="font-semibold text-lg mb-4">æœåŠ¡åˆ†å¸ƒ</h3>
          <ResponsiveContainer width="100%" height={300}>
            <PieChart>
              <Pie
                data={Object.entries(summary?.servicesBreakdown || {}).map(([name, data]) => ({
                  name,
                  value: data.count
                }))}
                cx="50%"
                cy="50%"
                labelLine={false}
                label
                outerRadius={100}
                fill="#8884d8"
                dataKey="value"
              >
                {Object.keys(summary?.servicesBreakdown || {}).map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </div>

        {/* å‘˜å·¥ä¸šç»©æ’è¡Œ */}
        <div className="card p-6">
          <h3 className="font-semibold text-lg mb-4">å‘˜å·¥ä¸šç»©æ’è¡Œ</h3>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart
              data={Object.entries(summary?.staffPerformance || {}).map(([name, data]) => ({
                name,
                revenue: data.revenue,
                appointments: data.appointments
              }))}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Bar dataKey="revenue" fill="#8884d8" name="æ”¶å…¥" />
              <Bar dataKey="appointments" fill="#82ca9d" name="é¢„çº¦æ•°" />
            </BarChart>
          </ResponsiveContainer>
        </div>

        {/* é«˜å³°æ—¶æ®µåˆ†æ */}
        <div className="card p-6">
          <h3 className="font-semibold text-lg mb-4">é«˜å³°æ—¶æ®µåˆ†æ</h3>
          <div className="space-y-3">
            {summary?.peakHours?.map((peak, index) => (
              <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded">
                <div>
                  <p className="font-semibold">#{index + 1} {peak.hour}</p>
                  <p className="text-sm text-gray-600">{peak.appointments} ä¸ªé¢„çº¦</p>
                </div>
                <div className="w-32 bg-gray-200 rounded-full h-2">
                  <div
                    className="bg-primary-500 h-2 rounded-full"
                    style={{ width: `${(peak.appointments / Math.max(...summary.peakHours.map(p => p.appointments))) * 100}%` }}
                  />
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* è¯¦ç»†æ•°æ®è¡¨æ ¼ */}
      <div className="card p-6">
        <h3 className="font-semibold text-lg mb-4">ä»Šæ—¥é¢„çº¦æ˜ç»†</h3>
        <AppointmentDetailsTable />
      </div>
    </div>
  );
}

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884D8'];
```

---

## ğŸš€ å®æ–½æ­¥éª¤

### Phase 1: æ•°æ®åº“å’ŒåŸºç¡€æ¶æ„ï¼ˆWeek 1-2ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
- âœ… æ‰©å±•æ•°æ®åº“schemaï¼ˆå‘˜å·¥ã€è´¢åŠ¡ã€æ—¥å†åŒæ­¥ï¼‰
- âœ… è¿è¡Œæ•°æ®åº“è¿ç§»
- âœ… é…ç½®Google Calendar API
- âœ… æ­å»ºåå°ä»»åŠ¡æ¡†æ¶ï¼ˆåŒæ­¥ã€ç»Ÿè®¡ï¼‰

### Phase 2: æœåŠ¡ç®¡ç†åŠŸèƒ½ï¼ˆWeek 3ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
- âœ… æœåŠ¡CRUD API
- âœ… æœåŠ¡ç®¡ç†ç•Œé¢
- âœ… å‘˜å·¥ç®¡ç†åŠŸèƒ½
- âœ… æœåŠ¡-å‘˜å·¥å…³è”

### Phase 3: Googleæ—¥å†åŒæ­¥ï¼ˆWeek 4-5ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
- âœ… OAuth 2.0 è®¤è¯æµç¨‹
- âœ… æ—¥å†äº‹ä»¶å¯¼å‡º
- âœ… æ—¥å†äº‹ä»¶å¯¼å…¥
- âœ… Webhook ç›‘å¬
- âœ… å®šæ—¶åŒæ­¥ä»»åŠ¡

### Phase 4: æ´¾å•ç³»ç»Ÿï¼ˆWeek 6ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
- âœ… æ™ºèƒ½æ´¾å•ç®—æ³•
- âœ… æ‰‹åŠ¨æ´¾å•åŠŸèƒ½
- âœ… æ´¾å•ç®¡ç†ç•Œé¢
- âœ… å‘˜å·¥å¯ç”¨æ€§æ£€æŸ¥

### Phase 5: è´¢åŠ¡æ ¸ç®—ï¼ˆWeek 7-8ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
- âœ… ææˆè®¡ç®—å¼•æ“
- âœ… è´¢åŠ¡è®°å½•è‡ªåŠ¨ç”Ÿæˆ
- âœ… ç»“ç®—åŠŸèƒ½
- âœ… è´¢åŠ¡ç®¡ç†ç•Œé¢

### Phase 6: ç»è¥çœ‹æ¿ï¼ˆWeek 9-10ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
- âœ… æ¯æ—¥æ•°æ®æ±‡æ€»ä»»åŠ¡
- âœ… ç»Ÿè®¡åˆ†ææœåŠ¡
- âœ… å¯è§†åŒ–å›¾è¡¨
- âœ… çœ‹æ¿ç•Œé¢

### Phase 7: æµ‹è¯•å’Œä¼˜åŒ–ï¼ˆWeek 11-12ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
- âœ… åŠŸèƒ½æµ‹è¯•
- âœ… æ€§èƒ½ä¼˜åŒ–
- âœ… ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- âœ… æ–‡æ¡£ç¼–å†™

---

## ğŸ“ ç¯å¢ƒå˜é‡é…ç½®

```env
# .env.local

# Google Calendar API
GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-client-secret
GOOGLE_REDIRECT_URI=http://localhost:3000/api/auth/google/callback

# åŒæ­¥é…ç½®
CALENDAR_SYNC_INTERVAL=300000  # 5åˆ†é’Ÿï¼ˆæ¯«ç§’ï¼‰
CALENDAR_WEBHOOK_TOKEN_SECRET=your-webhook-secret

# è´¢åŠ¡é…ç½®
PLATFORM_FEE_RATE=0.10  # 10% å¹³å°æŠ½æˆ
DEFAULT_COMMISSION_RATE=30  # é»˜è®¤30%å‘˜å·¥ææˆ

# ä»»åŠ¡è°ƒåº¦
ENABLE_CALENDAR_SYNC=true
ENABLE_DAILY_SUMMARY=true
DAILY_SUMMARY_TIME=02:00  # æ¯å¤©å‡Œæ™¨2ç‚¹ç”Ÿæˆå‰ä¸€å¤©æ±‡æ€»
```

---

## ğŸ¯ æ€»ç»“

è¿™å¥—å®Œæ•´çš„å•†æˆ·æ ¸å¿ƒåŠŸèƒ½æ–¹æ¡ˆæä¾›äº†ï¼š

### âœ… æ ¸å¿ƒèƒ½åŠ›

1. **å¤šæ¥æºé¢„çº¦ç»Ÿä¸€ç®¡ç†**
   - å¹³å°é¢„çº¦è‡ªåŠ¨åŒæ­¥åˆ°Google Calendar
   - Google Calendarå¤–éƒ¨äº‹ä»¶å¯å¯¼å…¥å¹³å°
   - Webhookå®æ—¶ç›‘å¬å˜åŒ–
   - åŒå‘åŒæ­¥ï¼Œæ•°æ®ä¸€è‡´

2. **çµæ´»çš„æœåŠ¡é…ç½®**
   - è‡ªå®šä¹‰æœåŠ¡é¡¹ç›®ã€ä»·æ ¼ã€æ—¶é•¿
   - æœåŠ¡åˆ†ç±»ç®¡ç†
   - å‘˜å·¥-æœåŠ¡å…³è”
   - åŠ¨æ€è°ƒæ•´æœåŠ¡çŠ¶æ€

3. **æ™ºèƒ½æ´¾å•ç³»ç»Ÿ**
   - è‡ªåŠ¨è¯„åˆ†é€‰æ‹©æœ€ä½³å‘˜å·¥
   - è€ƒè™‘æŠ€èƒ½ã€è¯„åˆ†ã€å·¥ä½œé‡
   - æ‰‹åŠ¨æ´¾å•çµæ´»å¹²é¢„
   - æ‰¹é‡æ´¾å•æå‡æ•ˆç‡

4. **è‡ªåŠ¨åŒ–è´¢åŠ¡æ ¸ç®—**
   - æ”¯æŒå¤šç§ææˆæ¨¡å¼
   - è‡ªåŠ¨è®¡ç®—åˆ†æˆ
   - å®æ—¶è´¢åŠ¡è®°å½•
   - æ‰¹é‡ç»“ç®—åŠŸèƒ½

5. **å®æ—¶ç»è¥çœ‹æ¿**
   - å…³é”®æŒ‡æ ‡ç›‘æ§
   - å¤šç»´åº¦æ•°æ®åˆ†æ
   - å¯è§†åŒ–å›¾è¡¨å±•ç¤º
   - è¶‹åŠ¿é¢„æµ‹åˆ†æ

### ğŸ“ˆ å•†ä¸šä»·å€¼

- **å•†æˆ·æ•ˆç‡æå‡ 70%**: è‡ªåŠ¨åŒ–æ´¾å•å’Œè´¢åŠ¡æ ¸ç®—
- **æ•°æ®å‡†ç¡®åº¦ 100%**: æ¶ˆé™¤äººå·¥ç»Ÿè®¡é”™è¯¯
- **å†³ç­–æ”¯æŒ**: æ•°æ®é©±åŠ¨çš„ç»è¥ä¼˜åŒ–
- **å‘˜å·¥æ»¡æ„åº¦æå‡**: å…¬å¹³é€æ˜çš„ææˆæœºåˆ¶
- **å®¢æˆ·ä½“éªŒä¼˜åŒ–**: å¤šå¹³å°é¢„çº¦æ— ç¼åŒæ­¥

---

**ä¸‹ä¸€æ­¥**: å¼€å§‹å®æ–½ Phase 1ï¼Œæ­å»ºæ•°æ®åº“å’ŒåŸºç¡€æ¶æ„ï¼
